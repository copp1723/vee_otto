import { Page } from 'playwright';
import { TIMEOUTS } from '../config/constants';

export interface RecoveryResult {
  success: boolean;
  method: string;
  error?: string;
}

export class WorkflowRecoveryService {
  private page: Page;
  private logger: any;

  constructor(page: Page, logger: any) {
    this.page = page;
    this.logger = logger;
  }

  /**\n   * Recover from vehicle navigation failures\n   */\n  async recoverFromNavigationFailure(): Promise<RecoveryResult> {\n    this.logger.info('üîÑ Attempting navigation recovery...');\n\n    try {\n      // Strategy 1: Check if we're still on inventory page\n      const currentUrl = this.page.url();\n      if (currentUrl.includes('/Inventory/')) {\n        this.logger.info('‚úÖ Still on inventory page, no recovery needed');\n        return { success: true, method: 'no-recovery-needed' };\n      }\n\n      // Strategy 2: Use browser back button\n      try {\n        await this.page.goBack();\n        await this.page.waitForLoadState('networkidle', { timeout: TIMEOUTS.NAVIGATION });\n        \n        if (this.page.url().includes('/Inventory/')) {\n          this.logger.info('‚úÖ Recovered using browser back button');\n          return { success: true, method: 'browser-back' };\n        }\n      } catch (e) {\n        this.logger.warn('Browser back failed:', e);\n      }\n\n      // Strategy 3: Direct navigation to inventory\n      const inventoryUrl = this.constructInventoryUrl(currentUrl);\n      if (inventoryUrl) {\n        await this.page.goto(inventoryUrl);\n        await this.page.waitForLoadState('networkidle', { timeout: TIMEOUTS.NAVIGATION });\n        \n        if (this.page.url().includes('/Inventory/')) {\n          this.logger.info('‚úÖ Recovered using direct navigation');\n          return { success: true, method: 'direct-navigation' };\n        }\n      }\n\n      return { success: false, method: 'navigation-recovery', error: 'All recovery methods failed' };\n\n    } catch (error) {\n      return { \n        success: false, \n        method: 'navigation-recovery', \n        error: error instanceof Error ? error.message : String(error) \n      };\n    }\n  }\n\n  /**\n   * Recover from window sticker access failures\n   */\n  async recoverFromWindowStickerFailure(vehicleVin: string): Promise<RecoveryResult> {\n    this.logger.info(`üîÑ Attempting window sticker recovery for ${vehicleVin}...`);\n\n    try {\n      // Strategy 1: Look for alternative sticker access methods\n      const alternativeSelectors = [\n        '//a[contains(text(), \"Monroney\")]',\n        '//a[contains(text(), \"MSRP\")]',\n        '//a[contains(text(), \"Sticker\")]',\n        '//button[contains(text(), \"Equipment\")]'\n      ];\n\n      for (const selector of alternativeSelectors) {\n        try {\n          const element = this.page.locator(selector).first();\n          if (await element.isVisible({ timeout: 2000 })) {\n            await element.click();\n            await this.page.waitForTimeout(2000);\n            \n            // Check if content is now available\n            const hasContent = await this.checkForStickerContent();\n            if (hasContent) {\n              this.logger.info(`‚úÖ Recovered window sticker access using: ${selector}`);\n              return { success: true, method: 'alternative-selector' };\n            }\n          }\n        } catch (e) {\n          continue;\n        }\n      }\n\n      // Strategy 2: Skip this vehicle and log for manual review\n      this.logger.warn(`‚ö†Ô∏è Window sticker unavailable for ${vehicleVin}, marking for manual review`);\n      return { success: false, method: 'skip-vehicle', error: 'Window sticker not accessible' };\n\n    } catch (error) {\n      return { \n        success: false, \n        method: 'window-sticker-recovery', \n        error: error instanceof Error ? error.message : String(error) \n      };\n    }\n  }\n\n  /**\n   * Recover from checkbox update failures\n   */\n  async recoverFromCheckboxFailure(): Promise<RecoveryResult> {\n    this.logger.info('üîÑ Attempting checkbox update recovery...');\n\n    try {\n      // Strategy 1: Refresh the page and try again\n      await this.page.reload({ waitUntil: 'networkidle' });\n      await this.page.waitForTimeout(3000);\n      \n      // Check if checkboxes are now accessible\n      const checkboxCount = await this.page.locator('input[type=\"checkbox\"]').count();\n      if (checkboxCount > 0) {\n        this.logger.info('‚úÖ Checkboxes accessible after page refresh');\n        return { success: true, method: 'page-refresh' };\n      }\n\n      // Strategy 2: Try to navigate back to Factory Equipment tab\n      const factoryTab = this.page.locator('//a[contains(text(), \"Factory Equipment\")]').first();\n      if (await factoryTab.isVisible({ timeout: 2000 })) {\n        await factoryTab.click();\n        await this.page.waitForTimeout(2000);\n        \n        const newCheckboxCount = await this.page.locator('input[type=\"checkbox\"]').count();\n        if (newCheckboxCount > 0) {\n          this.logger.info('‚úÖ Checkboxes accessible after tab navigation');\n          return { success: true, method: 'tab-navigation' };\n        }\n      }\n\n      return { success: false, method: 'checkbox-recovery', error: 'Checkboxes remain inaccessible' };\n\n    } catch (error) {\n      return { \n        success: false, \n        method: 'checkbox-recovery', \n        error: error instanceof Error ? error.message : String(error) \n      };\n    }\n  }\n\n  /**\n   * Recover from session timeout or authentication issues\n   */\n  async recoverFromSessionFailure(): Promise<RecoveryResult> {\n    this.logger.info('üîÑ Attempting session recovery...');\n\n    try {\n      // Check for session timeout indicators\n      const sessionTimeoutSelectors = [\n        '//div[contains(text(), \"session\") and contains(text(), \"expired\")]',\n        '//div[contains(text(), \"Please log in\")]',\n        '//div[contains(@class, \"login\")]'\n      ];\n\n      let sessionExpired = false;\n      for (const selector of sessionTimeoutSelectors) {\n        if (await this.page.locator(selector).isVisible({ timeout: 1000 })) {\n          sessionExpired = true;\n          break;\n        }\n      }\n\n      if (sessionExpired) {\n        this.logger.warn('‚ö†Ô∏è Session expired detected - requires re-authentication');\n        return { success: false, method: 'session-recovery', error: 'Session expired - re-authentication required' };\n      }\n\n      // Check if we're redirected to login page\n      const currentUrl = this.page.url();\n      if (currentUrl.includes('signin') || currentUrl.includes('login')) {\n        this.logger.warn('‚ö†Ô∏è Redirected to login page - authentication required');\n        return { success: false, method: 'session-recovery', error: 'Redirected to login - re-authentication required' };\n      }\n\n      return { success: true, method: 'session-check', error: 'Session appears to be valid' };\n\n    } catch (error) {\n      return { \n        success: false, \n        method: 'session-recovery', \n        error: error instanceof Error ? error.message : String(error) \n      };\n    }\n  }\n\n  /**\n   * Generic recovery for page load failures\n   */\n  async recoverFromPageLoadFailure(): Promise<RecoveryResult> {\n    this.logger.info('üîÑ Attempting page load recovery...');\n\n    try {\n      // Strategy 1: Wait longer for page to load\n      await this.page.waitForLoadState('networkidle', { timeout: TIMEOUTS.PAGE_LOAD * 2 });\n      \n      // Strategy 2: Check for loading indicators and wait\n      const loadingSelectors = [\n        '//div[contains(@class, \"loading\")]',\n        '//div[contains(@class, \"spinner\")]',\n        '//div[contains(@class, \"ext-el-mask\")]'\n      ];\n\n      for (const selector of loadingSelectors) {\n        try {\n          const loadingElement = this.page.locator(selector);\n          if (await loadingElement.isVisible({ timeout: 1000 })) {\n            this.logger.info('Waiting for loading indicator to disappear...');\n            await loadingElement.waitFor({ state: 'hidden', timeout: TIMEOUTS.PAGE_LOAD });\n          }\n        } catch (e) {\n          continue;\n        }\n      }\n\n      // Strategy 3: Refresh page if still having issues\n      const pageTitle = await this.page.title();\n      if (!pageTitle || pageTitle.includes('Error') || pageTitle.includes('404')) {\n        this.logger.info('Page appears to have errors, refreshing...');\n        await this.page.reload({ waitUntil: 'networkidle' });\n        await this.page.waitForTimeout(3000);\n      }\n\n      return { success: true, method: 'page-load-recovery' };\n\n    } catch (error) {\n      return { \n        success: false, \n        method: 'page-load-recovery', \n        error: error instanceof Error ? error.message : String(error) \n      };\n    }\n  }\n\n  /**\n   * Construct inventory URL from current URL\n   */\n  private constructInventoryUrl(currentUrl: string): string | null {\n    try {\n      const url = new URL(currentUrl);\n      return `${url.protocol}//${url.hostname}/Va/Inventory/`;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * Check if window sticker content is available\n   */\n  private async checkForStickerContent(): Promise<boolean> {\n    const contentSelectors = [\n      '//div[contains(@class, \"window-sticker\")]',\n      '//div[contains(@class, \"factory-equipment\")]',\n      '//div[contains(@class, \"sticker-content\")]'\n    ];\n\n    for (const selector of contentSelectors) {\n      try {\n        const element = this.page.locator(selector).first();\n        if (await element.isVisible({ timeout: 1000 })) {\n          const content = await element.textContent();\n          if (content && content.length > 50) {\n            return true;\n          }\n        }\n      } catch (e) {\n        continue;\n      }\n    }\n\n    return false;\n  }\n}